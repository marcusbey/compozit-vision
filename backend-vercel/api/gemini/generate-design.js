/**
 * Step 2: Professional Image Generation
 * Takes original image + enhanced prompt + reference images â†’ generates transformed design
 * Uses Nano Banana (Gemini 2.5 Flash with Vision)
 */

import { GoogleGenerativeAI } from '@google/generative-ai';

// Initialize Gemini with secure API key
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

export default async function handler(req, res) {
  // Set CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ 
      success: false, 
      error: 'Method not allowed. Use POST.' 
    });
  }

  const startTime = Date.now();

  try {
    const { 
      originalImage, 
      enhancedPrompt, 
      referenceImages = [],
      sessionId,
      userId
    } = req.body;

    // Validate required inputs
    if (!originalImage || !enhancedPrompt) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: originalImage, enhancedPrompt'
      });
    }

    console.log('ðŸŽ¨ Step 2: Generating design image with Nano Banana:', {
      userId,
      sessionId,
      enhancedPromptLength: enhancedPrompt.length,
      hasReferenceImages: referenceImages.length > 0,
      referenceCount: referenceImages.length
    });

    // Step 2: Generate transformed image using Gemini 2.5 Flash with Vision
    const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' });

    // Build application prompt for professional rendering standards
    const applicationPrompt = buildApplicationPrompt();

    // Combine enhanced prompt with application standards
    const combinedPrompt = `${enhancedPrompt}

${applicationPrompt}

${referenceImages.length > 0 ? buildReferenceContext(referenceImages) : ''}`;

    // Prepare content parts for generation
    const contentParts = [];

    // Add original image
    contentParts.push({
      inlineData: {
        data: originalImage.replace(/^data:image\/[a-z]+;base64,/, ''),
        mimeType: getImageMimeType(originalImage)
      }
    });

    // Add reference images if provided
    for (const refImage of referenceImages) {
      if (refImage.url) {
        try {
          const imageData = await processReferenceImage(refImage.url);
          contentParts.push({
            inlineData: {
              data: imageData.base64,
              mimeType: imageData.mimeType
            }
          });
        } catch (error) {
          console.warn(`âš ï¸ Failed to process reference image: ${error.message}`);
          // Continue without this reference image
        }
      }
    }

    // Add the combined prompt
    contentParts.push({ text: combinedPrompt });

    console.log('ðŸ–¼ï¸ Sending to Nano Banana:', {
      contentParts: contentParts.length,
      promptLength: combinedPrompt.length
    });

    // Generate the transformed image
    const result = await model.generateContent(contentParts);
    const responseText = result.response.text();

    // TODO: Extract actual generated image from result when available
    // For now, this is a mock response since Gemini doesn't return images yet
    
    console.log('âœ… Step 2 completed - Design generated by Nano Banana:', {
      responseLength: responseText.length,
      processingTime: Date.now() - startTime
    });

    return res.status(200).json({
      success: true,
      data: {
        generatedImage: {
          url: originalImage, // TODO: Replace with actual generated image URL/base64
          base64Data: null, // TODO: Add actual generated image data
          metadata: {
            model: 'nano-banana',
            modelId: 'gemini-2.0-flash-exp',
            processingTime: Date.now() - startTime,
            promptUsed: combinedPrompt.substring(0, 200) + '...',
            referenceImagesUsed: referenceImages.length,
            generationResponse: responseText.substring(0, 500) + '...'
          }
        },
        sessionId,
        enhancedPrompt,
        applicationPrompt,
        referenceImages: referenceImages.map(ref => ({
          type: ref.type,
          description: ref.description,
          processed: true
        }))
      }
    });

  } catch (error) {
    console.error('âŒ Step 2 image generation failed:', error);
    
    return res.status(500).json({
      success: false,
      error: 'Image generation failed',
      details: error.message,
      processingTime: Date.now() - startTime,
      step: 2,
      model: 'nano-banana'
    });
  }
}

/**
 * Build application prompt for professional rendering standards
 */
function buildApplicationPrompt() {
  return `PROFESSIONAL RENDERING REQUIREMENTS:
- High-quality interior design photography with natural lighting that enhances the space
- Realistic material textures: wood grain detail, fabric weave patterns, metal finishes, stone surfaces
- Accurate color representation with proper saturation and contrast
- Correct architectural perspective maintaining structural integrity and spatial proportions
- Sharp focus with professional depth of field, clear details in foreground and background
- Lighting should be natural and realistic: proper shadows, light reflection, ambient illumination
- Materials must look authentic: leather should have texture, marble should have veining, wood should show grain
- Maintain architectural logic: proper scale, realistic furniture placement, correct spatial relationships
- Professional color grading with balanced exposure and contrast
- Magazine-quality composition with proper framing and visual hierarchy
- 4K resolution detail level with crisp edges and fine texture definition
- Avoid oversaturation, unrealistic lighting, or artificial-looking materials`;
}

/**
 * Build reference context from reference images
 */
function buildReferenceContext(referenceImages) {
  if (!referenceImages.length) return '';
  
  const referenceDescriptions = referenceImages.map(ref => 
    `${ref.type}: ${ref.description}`
  ).join(', ');
  
  return `Reference inspirations from provided images: ${referenceDescriptions}. 
Incorporate these elements tastefully while maintaining the overall design cohesion and professional quality.`;
}

/**
 * Process reference image (convert to base64 if needed)
 */
async function processReferenceImage(imageUrl) {
  // If it's already base64, extract it
  if (imageUrl.startsWith('data:image/')) {
    return {
      base64: imageUrl.replace(/^data:image\/[a-z]+;base64,/, ''),
      mimeType: getImageMimeType(imageUrl)
    };
  }

  // If it's a URL, we would need to fetch it
  // For now, throw an error since we expect base64
  throw new Error('Reference images must be provided as base64 data');
}

/**
 * Get MIME type from base64 data string
 */
function getImageMimeType(base64String) {
  if (base64String.includes('data:image/jpeg')) return 'image/jpeg';
  if (base64String.includes('data:image/jpg')) return 'image/jpeg';
  if (base64String.includes('data:image/png')) return 'image/png';
  if (base64String.includes('data:image/webp')) return 'image/webp';
  if (base64String.includes('data:image/gif')) return 'image/gif';
  
  // Default to JPEG
  return 'image/jpeg';
}